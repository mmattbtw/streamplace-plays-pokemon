<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stream Overlay</title>
    <style>
      :root {
        --page-bg: #dff0ff;
        --bg-chat: rgba(255, 252, 236, 0.92);
        --bg-queue: rgba(255, 255, 255, 0.92);
        --border: rgba(44, 65, 122, 0.28);
        --text: #24315f;
        --muted: #5267a0;
        --active: #ff5252;
        --queued: #3f7bf7;
        --done: #8f9fc8;
        --error: #d64545;
        --yellow: #ffd84b;
        --blue: #3f7bf7;
        --red: #ff5252;
        --cream: #fff9de;
        --panel-shadow: rgba(44, 65, 122, 0.16);
        --panel-item-bg: rgba(255, 255, 255, 0.9);
        --queue-pill-bg: #fff9de;
        --queue-command-bg: #ffeaea;
        --queue-command-text: #a32626;
        --queue-user-text: #2b3f74;
        --overlay-dot: rgba(63, 123, 247, 0.1);
        --overlay-dot-strong: rgba(255, 216, 75, 0.2);
        --ability-enabled-bg: #e7ffe8;
        --ability-enabled-text: #1f7a2f;
        --ability-enabled-border: rgba(53, 176, 78, 0.82);
        --ability-disabled-bg: #fff2f2;
        --ability-disabled-border: rgba(214, 69, 69, 0.7);
        --orb-outline: rgba(20, 32, 70, 0.22);
        --orb-band: rgba(26, 36, 74, 0.7);
        --orb-button: #ffffff;
        --orb-button-ring: rgba(26, 36, 74, 0.42);
        --orb-label-bg: rgba(255, 255, 255, 0.86);
        --orb-label-text: #2a3970;
        --orb-opacity: 0.42;
        --bg-howto: rgba(255, 252, 236, 0.92);
        --howto-border: rgba(63, 123, 247, 0.44);
        --howto-label: #3f7bf7;
        --howto-tip-bg: rgba(255, 255, 255, 0.64);
        --howto-tip-text: #2a3b70;
        --howto-icon-bg: rgba(63, 123, 247, 0.12);
        --queue-panel-height: 84px;
        --chat-panel-height: 72vh;
        --frame-radius: 20px;
        --panel-offset-x: 1.2vw;
        --panel-offset-y: 2vh;
      }

      :root[data-theme="night"] {
        --page-bg: #101a35;
        --bg-chat: rgba(22, 33, 66, 0.9);
        --bg-queue: rgba(20, 29, 56, 0.9);
        --border: rgba(132, 162, 255, 0.32);
        --text: #e8efff;
        --muted: #afc3f4;
        --active: #ff7a7a;
        --queued: #86b2ff;
        --done: #7788b0;
        --error: #ff9a9a;
        --cream: #23325e;
        --panel-shadow: rgba(6, 10, 24, 0.4);
        --panel-item-bg: rgba(27, 39, 74, 0.9);
        --queue-pill-bg: #1f2e58;
        --queue-command-bg: #3c2a4f;
        --queue-command-text: #ffd0d0;
        --queue-user-text: #e4ecff;
        --overlay-dot: rgba(134, 178, 255, 0.08);
        --overlay-dot-strong: rgba(255, 237, 143, 0.12);
        --ability-enabled-bg: #213d2b;
        --ability-enabled-text: #b8ffca;
        --ability-enabled-border: rgba(104, 230, 138, 0.78);
        --ability-disabled-bg: #3c2630;
        --ability-disabled-border: rgba(255, 144, 144, 0.72);
        --orb-outline: rgba(186, 204, 255, 0.28);
        --orb-band: rgba(209, 222, 255, 0.55);
        --orb-button: #dce7ff;
        --orb-button-ring: rgba(186, 204, 255, 0.46);
        --orb-label-bg: rgba(20, 30, 58, 0.78);
        --orb-label-text: #d5e4ff;
        --orb-opacity: 0.32;
        --bg-howto: rgba(20, 29, 56, 0.9);
        --howto-border: rgba(132, 162, 255, 0.45);
        --howto-label: #9ec0ff;
        --howto-tip-bg: rgba(34, 49, 92, 0.72);
        --howto-tip-text: #e3edff;
        --howto-icon-bg: rgba(132, 162, 255, 0.18);
        --queue-panel-height: 84px;
        --chat-panel-height: 72vh;
        --frame-radius: 20px;
        --panel-offset-x: 1.2vw;
        --panel-offset-y: 2vh;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: var(--page-bg);
        color: var(--text);
        font-family: "Avenir Next", "Segoe UI", sans-serif;
        transition: background-color 280ms ease, color 280ms ease;
      }

      .overlay {
        position: relative;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
      }

      .overlay::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .overlay::after {
        border: 12px solid rgba(255, 255, 255, 0.18);
        border-radius: var(--frame-radius);
        left: var(--panel-offset-x);
        right: var(--panel-offset-x);
        top: var(--panel-offset-y);
        bottom: var(--panel-offset-y);
        opacity: 0.4;
        z-index: 0;
      }

      .orb-field {
        position: absolute;
        inset: 0;
        z-index: 1;
        pointer-events: none;
      }

      .ball-orb {
        position: absolute;
        width: 84px;
        height: 84px;
        border-radius: 50%;
        overflow: visible;
        opacity: var(--orb-opacity);
        transform: scale(var(--orb-scale, 1));
        will-change: left, top, transform;
      }
      .ball-sprite {
        width: 100%;
        height: 100%;
        object-fit: contain;
        image-rendering: pixelated;
        filter: drop-shadow(0 5px 10px rgba(10, 18, 36, 0.35));
        user-select: none;
      }

      .chat-panel {
        position: absolute;
        top: var(--panel-offset-y);
        right: var(--panel-offset-x);
        width: min(32vw, 460px);
        height: var(--chat-panel-height);
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 14px;
        border: 2px solid var(--border);
        border-radius: var(--frame-radius);
        background: var(--bg-chat);
        box-shadow: 0 10px 24px var(--panel-shadow);
        z-index: 2;
        overflow: hidden;
        transition: background-color 280ms ease, border-color 280ms ease, box-shadow 280ms ease;
      }

      .panel-title {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 12px;
        color: var(--blue);
        margin: 0 0 6px;
        font-weight: 800;
      }

      .panel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .ability-badge {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border: 2px solid rgba(63, 123, 247, 0.5);
        border-radius: 999px;
        padding: 5px 10px;
        background: var(--cream);
        color: var(--muted);
        white-space: nowrap;
        font-weight: 700;
        transition: background-color 280ms ease, border-color 280ms ease, color 280ms ease;
      }

      .ability-badge.enabled {
        border-color: var(--ability-enabled-border);
        color: var(--ability-enabled-text);
        background: var(--ability-enabled-bg);
      }

      .ability-badge.disabled {
        border-color: var(--ability-disabled-border);
        color: var(--error);
        background: var(--ability-disabled-bg);
      }

      .chat-list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        scrollbar-width: none;
      }

      .chat-list::-webkit-scrollbar {
        display: none;
      }

      .chat-item {
        border: 2px solid rgba(63, 123, 247, 0.22);
        border-radius: 16px;
        padding: 9px 11px;
        background: var(--panel-item-bg);
        animation: enter 220ms ease-out;
        display: grid;
        grid-template-columns: 34px 1fr;
        gap: 9px;
        transition: background-color 280ms ease, border-color 280ms ease;
      }

      .avatar {
        width: 34px;
        height: 34px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid rgba(255, 82, 82, 0.52);
        background: rgba(255, 216, 75, 0.4);
      }

      .avatar.fallback {
        display: grid;
        place-items: center;
        font-size: 12px;
        font-weight: 700;
        color: var(--text);
      }

      .chat-user {
        font-size: 15px;
        font-weight: 750;
        color: var(--queued);
      }

      .chat-handle {
        font-size: 13px;
        color: var(--muted);
      }

      .chat-text {
        display: block;
        margin-top: 3px;
        font-size: 17px;
        line-height: 1.2;
        word-break: break-word;
      }

      .how-to-play-panel {
        position: absolute;
        right: var(--panel-offset-x);
        top: calc(var(--panel-offset-y) + var(--chat-panel-height) + 8px);
        bottom: calc(var(--panel-offset-y) + var(--queue-panel-height) + 8px);
        width: min(32vw, 460px);
        padding: 8px 12px 10px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 6px;
        border: 2px dashed var(--howto-border);
        border-radius: 14px;
        background: var(--bg-howto);
        box-shadow: 0 7px 16px var(--panel-shadow);
        z-index: 2;
        transition: background-color 280ms ease, border-color 280ms ease, box-shadow 280ms ease;
      }

      .how-to-play-label {
        margin: 0;
        color: var(--howto-label);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 10px;
        font-weight: 800;
        text-align: center;
      }

      .how-to-play-message {
        margin: 4px 0 0;
        width: 100%;
        font-size: 14px;
        font-weight: 700;
        line-height: 1.25;
        min-height: calc(1.25em * 2 + 12px);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--howto-tip-text);
        background: var(--howto-tip-bg);
        border: 1px solid var(--howto-border);
        border-radius: 10px;
        padding: 4px 6px;
        text-align: center;
        transition: opacity 180ms ease;
      }

      .how-to-play-message.is-changing {
        opacity: 0;
      }

      .how-to-play-icons {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        flex-wrap: wrap;
      }

      .howto-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 38px;
        height: 20px;
        border-radius: 7px;
        border: 1px solid var(--howto-border);
        background: var(--howto-icon-bg);
        color: var(--howto-tip-text);
        font-size: 11px;
        line-height: 1;
        font-weight: 800;
        padding: 0 6px;
      }

      .howto-icon.long {
        min-width: 54px;
      }

      .queue-panel {
        position: absolute;
        left: var(--panel-offset-x);
        right: var(--panel-offset-x);
        bottom: var(--panel-offset-y);
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 8px 14px 10px;
        border: 2px solid var(--border);
        border-radius: var(--frame-radius);
        background: var(--bg-queue);
        box-shadow: 0 8px 20px var(--panel-shadow);
        z-index: 2;
        overflow: visible;
        transition: background-color 280ms ease, border-color 280ms ease, box-shadow 280ms ease;
      }

      .spam-toast {
        position: absolute;
        left: 10px;
        right: 10px;
        top: 8px;
        transform: translateY(-140%) scale(0.96);
        opacity: 0;
        pointer-events: none;
        width: auto;
        text-align: center;
        padding: 14px 20px;
        border-radius: 14px;
        border: 3px solid transparent;
        font-size: clamp(18px, 2.6vw, 34px);
        font-weight: 900;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        z-index: 4;
        transition: transform 700ms cubic-bezier(0.2, 0.9, 0.15, 1), opacity 220ms ease;
      }

      .spam-toast.show {
        transform: translateY(0) scale(1);
        opacity: 1;
      }

      .spam-toast.enabled {
        background: rgba(51, 185, 83, 0.92);
        border-color: rgba(215, 255, 223, 0.92);
        color: #ffffff;
        box-shadow: 0 14px 28px rgba(27, 116, 47, 0.42);
      }

      .spam-toast.disabled {
        background: rgba(211, 68, 68, 0.93);
        border-color: rgba(255, 219, 219, 0.92);
        color: #ffffff;
        box-shadow: 0 14px 28px rgba(120, 28, 28, 0.42);
      }

      .queue-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .queue-list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: flex;
        gap: 6px;
        align-items: center;
        overflow-x: auto;
        scrollbar-width: none;
      }

      .queue-list::-webkit-scrollbar {
        display: none;
      }

      .queue-item {
        padding: 4px 8px 4px 9px;
        border-radius: 999px;
        border: 2px solid rgba(63, 123, 247, 0.28);
        background: var(--queue-pill-bg);
        display: flex;
        align-items: center;
        gap: 7px;
        white-space: nowrap;
        transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease, opacity 140ms ease;
      }

      .queue-item .queue-user {
        color: var(--queue-user-text);
        font-size: 13px;
        line-height: 1;
        font-weight: 700;
      }

      .queue-item .queue-separator {
        color: rgba(82, 103, 160, 0.8);
        font-size: 12px;
        line-height: 1;
      }

      .queue-item .queue-command {
        min-width: 22px;
        height: 22px;
        padding: 0 8px;
        border-radius: 999px;
        border: 2px solid rgba(255, 82, 82, 0.45);
        background: var(--queue-command-bg);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: var(--queue-command-text);
        font-size: 14px;
        line-height: 1;
        font-weight: 700;
        letter-spacing: 0.01em;
        transition: background-color 280ms ease, border-color 280ms ease, color 280ms ease;
      }

      .queue-item .queue-command.compact-circle {
        min-width: 22px;
        width: 22px;
        padding: 0;
      }

      .queue-item .queue-repeat {
        color: #3f7bf7;
        font-size: 12px;
        font-weight: 700;
      }

      .queue-item.queued {
        border-color: rgba(63, 123, 247, 0.52);
      }

      .queue-item.queued .state {
        color: var(--queued);
      }

      .queue-item.active {
        border-color: var(--active);
        box-shadow: 0 0 0 2px rgba(255, 82, 82, 0.2), 0 4px 12px rgba(255, 82, 82, 0.22);
        transform: translateY(-1px);
        background: #fff0f0;
      }

      .queue-item.done {
        opacity: 0.58;
        border-color: rgba(143, 159, 200, 0.5);
      }

      .queue-item.error {
        border-color: rgba(255, 126, 126, 0.6);
        color: var(--error);
      }

      .status {
        font-size: 12px;
        color: var(--muted);
        font-weight: 700;
      }

      @keyframes enter {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 900px) {
        .chat-panel {
          width: min(56vw, 420px);
          height: 58vh;
        }

        .how-to-play-panel {
          display: none;
        }

        .chat-text {
          font-size: 15px;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .ball-orb {
          transition: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="overlay">
      <div class="orb-field" aria-hidden="true"></div>

      <section class="chat-panel">
        <ul id="chat-list" class="chat-list"></ul>
        <div id="spam-toast" class="spam-toast" aria-live="polite"></div>
      </section>

      <section class="how-to-play-panel" aria-live="polite">
        <p class="how-to-play-label">How To Play</p>
        <div class="how-to-play-icons" aria-hidden="true">
          <span class="howto-icon">up</span>
          <span class="howto-icon">down</span>
          <span class="howto-icon">left</span>
          <span class="howto-icon">right</span>
          <span class="howto-icon">A</span>
          <span class="howto-icon">B</span>
          <span class="howto-icon long">start</span>
          <span class="howto-icon long">select</span>
        </div>
        <p id="how-to-play-message" class="how-to-play-message"></p>
      </section>

      <section class="queue-panel">
        <ul id="queue-list" class="queue-list"></ul>
        <div class="queue-footer">
          <div id="status" class="status">Connecting...</div>
          <div id="spam-ability" class="ability-badge">Spam: Unknown</div>
        </div>
      </section>
    </div>

    <script>
      const DAY_START_HOUR = 6;
      const NIGHT_START_HOUR = 18;
      const chatList = document.getElementById("chat-list");
      const queueList = document.getElementById("queue-list");
      const statusEl = document.getElementById("status");
      const spamAbilityEl = document.getElementById("spam-ability");
      const spamToastEl = document.getElementById("spam-toast");
      const howToPlayMessageEl = document.getElementById("how-to-play-message");
      const queuePanelEl = document.querySelector(".queue-panel");
      const orbFieldEl = document.querySelector(".orb-field");
      const query = new URLSearchParams(window.location.search);
      const chatMode = query.get("chat") || "non_commands";
      const chatNodes = new Map();
      const queueNodes = new Map();
      let lastSpamEnabled = null;
      let lastTestMessageId = "";
      let spamToastTimer = null;
      let howToPlayIndex = 0;
      const HOW_TO_PLAY_TIPS = [
        "Type buttons as commands like a, b, up, down, start, or select.",
        "Hold a button longer with a trailing dash: a-",
        "Spam a command by adding a repeat count: a x10",
        "Combine inputs in one command with plus: a+b",
      ];
      const BALL_SPRITES = [
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/great-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/ultra-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/master-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/premier-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/dusk-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/timer-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/luxury-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/quick-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/heal-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/nest-ball.png",
        "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/repeat-ball.png",
      ];

      function themeByHour(hour) {
        return hour >= DAY_START_HOUR && hour < NIGHT_START_HOUR ? "day" : "night";
      }

      function applyThemeFromLocalTime() {
        const now = new Date();
        document.documentElement.setAttribute("data-theme", themeByHour(now.getHours()));
      }

      function showSpamToast(enabled) {
        if (!spamToastEl) {
          return;
        }

        spamToastEl.textContent = enabled ? "SPAM COMMANDS ENABLED" : "SPAM COMMANDS DISABLED";
        spamToastEl.classList.toggle("enabled", enabled);
        spamToastEl.classList.toggle("disabled", !enabled);
        spamToastEl.classList.remove("show");
        void spamToastEl.offsetWidth;
        spamToastEl.classList.add("show");

        if (spamToastTimer) {
          clearTimeout(spamToastTimer);
        }
        spamToastTimer = setTimeout(() => {
          spamToastEl.classList.remove("show");
        }, 2400);
      }

      function populateOrbField() {
        if (!orbFieldEl) {
          return;
        }
        const orbCount = 72;
        orbFieldEl.replaceChildren();
        const width = window.innerWidth;
        const height = window.innerHeight;

        for (let i = 0; i < orbCount; i += 1) {
          const orb = document.createElement("div");
          orb.className = "ball-orb";
          const scale = 0.56 + Math.random() * 0.7;
          orb.style.setProperty("--orb-scale", scale.toFixed(3));
          orb.style.opacity = `${0.2 + Math.random() * 0.35}`;
          orb.style.left = `${Math.floor(Math.random() * Math.max(1, width - 84))}px`;
          orb.style.top = `${Math.floor(Math.random() * Math.max(1, height - 84))}px`;

          const img = document.createElement("img");
          img.className = "ball-sprite";
          img.src = BALL_SPRITES[i % BALL_SPRITES.length];
          img.alt = "";
          orb.append(img);
          orbFieldEl.append(orb);
        }
      }

      function startOrbBounce() {
        if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
          return;
        }

        const overlay = document.querySelector(".overlay");
        const orbs = Array.from(document.querySelectorAll(".ball-orb"));
        if (!overlay || orbs.length === 0) {
          return;
        }

        const states = orbs.map((orb, index) => {
          const scale = parseFloat(getComputedStyle(orb).getPropertyValue("--orb-scale")) || 1;
          const width = orb.offsetWidth * scale;
          const height = orb.offsetHeight * scale;
          const angle = ((index * 67) % 360) * (Math.PI / 180);
          const speed = 14 + (index % 5) * 3;

          return {
            orb,
            x: orb.offsetLeft,
            y: orb.offsetTop,
            vx: Math.cos(angle) * (speed / 1000),
            vy: Math.sin(angle) * (speed / 1000),
            width,
            height,
          };
        });

        function refreshBounds() {
          const maxWidth = window.innerWidth;
          const maxHeight = window.innerHeight;

          for (const state of states) {
            const scale = parseFloat(getComputedStyle(state.orb).getPropertyValue("--orb-scale")) || 1;
            state.width = state.orb.offsetWidth * scale;
            state.height = state.orb.offsetHeight * scale;
            state.x = Math.min(Math.max(state.x, 0), Math.max(0, maxWidth - state.width));
            state.y = Math.min(Math.max(state.y, 0), Math.max(0, maxHeight - state.height));
            state.orb.style.left = `${state.x}px`;
            state.orb.style.top = `${state.y}px`;
          }
        }

        let lastTs = performance.now();
        refreshBounds();

        function frame(ts) {
          const dt = Math.min(50, ts - lastTs);
          lastTs = ts;
          const maxWidth = window.innerWidth;
          const maxHeight = window.innerHeight;

          for (const state of states) {
            if (getComputedStyle(state.orb).display === "none") {
              continue;
            }

            state.x += state.vx * dt;
            state.y += state.vy * dt;

            const maxX = Math.max(0, maxWidth - state.width);
            const maxY = Math.max(0, maxHeight - state.height);

            if (state.x <= 0) {
              state.x = 0;
              state.vx = Math.abs(state.vx);
            } else if (state.x >= maxX) {
              state.x = maxX;
              state.vx = -Math.abs(state.vx);
            }

            if (state.y <= 0) {
              state.y = 0;
              state.vy = Math.abs(state.vy);
            } else if (state.y >= maxY) {
              state.y = maxY;
              state.vy = -Math.abs(state.vy);
            }

            state.orb.style.left = `${state.x}px`;
            state.orb.style.top = `${state.y}px`;
          }

          requestAnimationFrame(frame);
        }

        window.addEventListener("resize", refreshBounds);
        requestAnimationFrame(frame);
      }

      function setHowToPlayTip(nextIndex) {
        if (!howToPlayMessageEl) {
          return;
        }

        howToPlayIndex = nextIndex % HOW_TO_PLAY_TIPS.length;
        const nextTip = HOW_TO_PLAY_TIPS[howToPlayIndex];
        const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        if (prefersReducedMotion) {
          howToPlayMessageEl.textContent = nextTip;
          return;
        }

        howToPlayMessageEl.classList.add("is-changing");
        setTimeout(() => {
          howToPlayMessageEl.textContent = nextTip;
          howToPlayMessageEl.classList.remove("is-changing");
        }, 170);
      }

      function startHowToPlayRotation() {
        if (!howToPlayMessageEl || HOW_TO_PLAY_TIPS.length === 0) {
          return;
        }

        howToPlayMessageEl.textContent = HOW_TO_PLAY_TIPS[0];
        if (HOW_TO_PLAY_TIPS.length === 1) {
          return;
        }

        setInterval(() => {
          setHowToPlayTip((howToPlayIndex + 1) % HOW_TO_PLAY_TIPS.length);
        }, 4200);
      }

      function syncHowToPlayGap() {
        if (!queuePanelEl) {
          return;
        }
        const queueHeight = Math.ceil(queuePanelEl.getBoundingClientRect().height);
        document.documentElement.style.setProperty("--queue-panel-height", `${queueHeight}px`);
      }

      applyThemeFromLocalTime();
      populateOrbField();
      setInterval(applyThemeFromLocalTime, 60 * 1000);
      startOrbBounce();
      startHowToPlayRotation();
      syncHowToPlayGap();
      window.addEventListener("resize", syncHowToPlayGap);

      function initial(text) {
        const trimmed = (text || "").trim();
        return trimmed.length > 0 ? trimmed[0].toUpperCase() : "?";
      }

      function shortDid(did) {
        if (!did) return "";
        return did.length <= 18 ? did : `${did.slice(0, 10)}...${did.slice(-5)}`;
      }

      function stickToEnd(listEl, horizontal = false) {
        if (horizontal) {
          listEl.scrollLeft = listEl.scrollWidth;
          return;
        }
        listEl.scrollTop = listEl.scrollHeight;
      }

      function scheduleStickToEnd(listEl, horizontal = false) {
        requestAnimationFrame(() => {
          stickToEnd(listEl, horizontal);
          setTimeout(() => stickToEnd(listEl, horizontal), 0);
        });
      }

      function filterChat(chat) {
        if (chatMode === "all") {
          return chat;
        }
        if (chatMode === "commands") {
          return chat.filter((msg) => msg.isCommand);
        }
        return chat.filter((msg) => !msg.isCommand);
      }

      function randomBallSprite() {
        if (BALL_SPRITES.length === 0) {
          return "";
        }
        return BALL_SPRITES[Math.floor(Math.random() * BALL_SPRITES.length)];
      }

      function createAvatarNode(url, label, className, onLoad) {
        if (url) {
          const img = document.createElement("img");
          img.className = className;
          img.src = url;
          img.alt = label || "";
          img.addEventListener("load", onLoad, { once: true });
          img.addEventListener(
            "error",
            () => {
              const fallbackUrl = randomBallSprite();
              if (!fallbackUrl || img.src === fallbackUrl) {
                return;
              }
              img.src = fallbackUrl;
              img.alt = `${label || "Trainer"} avatar fallback`;
            },
            { once: true }
          );
          return img;
        }
        const fallback = document.createElement("span");
        fallback.className = `${className} fallback`;
        fallback.textContent = initial(label);
        return fallback;
      }

      function setAvatar(container, url, label, className, onLoad) {
        if (
          container.dataset.avatarUrl === (url || "") &&
          container.dataset.avatarLabel === (label || "")
        ) {
          return;
        }

        container.dataset.avatarUrl = url || "";
        container.dataset.avatarLabel = label || "";
        container.replaceChildren(createAvatarNode(url, label, className, onLoad));
      }

      function createChatNode() {
        const li = document.createElement("li");
        li.className = "chat-item";

        const avatarWrap = document.createElement("div");
        avatarWrap.className = "avatar-slot";

        const body = document.createElement("div");
        const user = document.createElement("span");
        user.className = "chat-user";
        const handle = document.createElement("span");
        handle.className = "chat-handle";
        const text = document.createElement("span");
        text.className = "chat-text";

        body.append(user, handle, text);
        li.append(avatarWrap, body);
        li._avatarWrap = avatarWrap;
        li._user = user;
        li._handle = handle;
        li._text = text;
        return li;
      }

      function patchChatNode(li, msg) {
        setAvatar(li._avatarWrap, msg.avatarUrl, msg.user, "avatar", () => scheduleStickToEnd(chatList));
        li._user.textContent = msg.user || "";
        li._handle.textContent = msg.handle ? ` @${msg.handle.replace(/^@/, "")}` : ` ${shortDid(msg.did)}`;
        li._text.textContent = msg.text || "";
      }

      function createQueueNode() {
        const li = document.createElement("li");
        li.className = "queue-item";

        const user = document.createElement("span");
        user.className = "queue-user";
        const separator = document.createElement("span");
        separator.className = "queue-separator";
        separator.textContent = ":";
        const cmd = document.createElement("span");
        cmd.className = "queue-command";
        const repeat = document.createElement("span");
        repeat.className = "queue-repeat";

        li.append(user, separator, cmd, repeat);
        li._user = user;
        li._cmd = cmd;
        li._repeat = repeat;
        return li;
      }

      function formatQueueCommand(command) {
        const normalized = (command || "").trim().toLowerCase();
        if (!normalized) {
          return "";
        }

        const isHold = normalized.endsWith("-");
        const baseCommand = isHold ? normalized.slice(0, -1) : normalized;
        const tokens = baseCommand
          .split("+")
          .map((part) => part.trim())
          .filter(Boolean)
          .map((part) => {
            switch (part) {
              case "up":
                return "↑";
              case "down":
                return "↓";
              case "left":
                return "←";
              case "right":
                return "→";
              case "a":
                return "A";
              case "b":
                return "B";
              case "l":
                return "L";
              case "r":
                return "R";
              case "start":
                return "START";
              case "select":
                return "SELECT";
              default:
                return part.toUpperCase();
            }
          });

        return `${tokens.join("+")}${isHold ? "-" : ""}`;
      }

      function queueLabel(item) {
        return item.handle ? `@${item.handle.replace(/^@/, "")}` : shortDid(item.did);
      }

      function collapseQueue(queue, activeCommandId) {
        const collapsed = [];

        for (const item of queue) {
          const activeState = activeCommandId === item.id ? "active" : item.status;
          const last = collapsed[collapsed.length - 1];
          const canMerge =
            last &&
            last.status !== "active" &&
            activeState !== "active" &&
            last.userLabel === queueLabel(item) &&
            last.commandLabel === formatQueueCommand(item.command);

          if (canMerge) {
            last.count += 1;
            continue;
          }

          collapsed.push({
            id: item.id,
            status: activeState,
            userLabel: queueLabel(item),
            commandLabel: formatQueueCommand(item.command),
            count: 1,
          });
        }

        return collapsed;
      }

      function patchQueueNode(li, item) {
        li.className = `queue-item ${item.status || "queued"}`;
        li._user.textContent = item.userLabel;
        li._cmd.textContent = item.commandLabel;
        li._cmd.classList.toggle(
          "compact-circle",
          /^[←→↑↓ABLR]$/.test(item.commandLabel || ""),
        );
        li._repeat.textContent = item.count > 1 ? `x${item.count}` : "";
      }

      function reconcileList(listEl, nodesById, items, patchNode, createNode, ...patchArgs) {
        const seen = new Set();
        let index = 0;

        for (const item of items) {
          const id = item.id;
          let node = nodesById.get(id);
          if (!node) {
            node = createNode();
            node.dataset.id = id;
            nodesById.set(id, node);
          }
          patchNode(node, item, ...patchArgs);
          const currentAtIndex = listEl.children[index] || null;
          if (currentAtIndex !== node) {
            listEl.insertBefore(node, currentAtIndex);
          }
          seen.add(id);
          index += 1;
        }

        for (const [id, node] of nodesById) {
          if (seen.has(id)) {
            continue;
          }
          nodesById.delete(id);
          node.remove();
        }
      }

      function render(state) {
        reconcileList(chatList, chatNodes, filterChat(state.chat), patchChatNode, createChatNode);
        scheduleStickToEnd(chatList);

        const collapsedQueue = collapseQueue(state.queue, state.activeCommandId);
        reconcileList(queueList, queueNodes, collapsedQueue, patchQueueNode, createQueueNode);
        scheduleStickToEnd(queueList, true);
        syncHowToPlayGap();

        if (spamAbilityEl && state.spamAbility) {
          const enabled = Boolean(state.spamAbility.enabled);
          spamAbilityEl.classList.toggle("enabled", enabled);
          spamAbilityEl.classList.toggle("disabled", !enabled);
          spamAbilityEl.textContent = `Spam: ${enabled ? "ENABLED" : "DISABLED"} (${state.spamAbility.uniqueChatters}/${state.spamAbility.threshold} chatters)`;

          if (lastSpamEnabled === null) {
            lastSpamEnabled = enabled;
          } else if (lastSpamEnabled !== enabled) {
            showSpamToast(enabled);
            lastSpamEnabled = enabled;
          }
        }
        const newestMessage = state.chat.at(-1);
        if (
          newestMessage &&
          newestMessage.id !== lastTestMessageId &&
          typeof newestMessage.text === "string" &&
          newestMessage.text.trim().toLowerCase() === "!test"
        ) {
          lastTestMessageId = newestMessage.id;
          showSpamToast(Boolean(state.spamAbility?.enabled));
        }
      }

      const events = new EventSource("/events");

      events.onopen = () => {
        statusEl.textContent = "Connected";
      };

      events.onerror = () => {
        statusEl.textContent = "Reconnecting...";
      };

      events.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          render(data);
        } catch {
          statusEl.textContent = "Bad event payload";
        }
      };
    </script>
  </body>
</html>
